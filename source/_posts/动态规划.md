---
title: 动态规划
date: 2021-08-31 15:24:23
tags: algorithm
---

动态规划问题的一般形式就是**求最值**。比如说让你求最⻓递增子序列、最小编辑距离等等。因为要求最值，肯定要把所有可行的答案穷举出来，然后在其中找最值。但是动态规划的穷举有点特别，因为这类问题存在「重叠子问题」，如果暴力穷举的话效率会极其低下，所以需要「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。因为存在「重叠子问题」，所以一定会具备「最优子结构」，只有列出正确的「状态转移方 程」才能正确地穷举。

「状态转移方程」的简单例子：`f(n) = f(n - 1) + f(n - 2)`，你把 f(n) 想做一个状态 n，这个状态 n 是由状态 n - 1 和状态 n - 2 相加转移而来，这就叫状态转移。

写出「状态转移方程」是最困难的，提供一个框架辅助思考：
明确「状态」 -> 定义 dp 数组/函数的含义 -> 明确「选择」-> 明确 base case。

### 零钱兑换
有 k 种面值的硬币，面值分别为 c1, c2 ... ck ，每种硬币的数量无限，问最少需要几枚硬币凑出金额 amount，如果不可能凑出，算法返回 -1。[LeetCode地址](https://leetcode-cn.com/problems/coin-change/)

这个问题具备「最优子结构」。比如你想求 amount = 11 时的最少硬币数(原问题)，如果你知道凑出 amount = 10 的最少硬币 数(子问题)，你只需要把子问题的答案加一(再选一枚面值为 1 的硬币) 就是原问题的答案，因为硬币的数量是没有限制的，子问题之间没有相互制，是互相独立的。

先确定「状态」，也就是原问题和子问题中变化的变量。由于硬币数量无限，所以唯一的状态就是目标金额 amount 。

确定 dp 函数的定义: 当前的目标金额是 n ，至少需要 dp(n) 个硬币凑出该金额。

确定「选择」并择优，也就是对于每个状态，可以做出什么选择改变当前状态。

最后明确 base case，也就终止条件。

```python
def coinChange(coins, amount):
  # dp 函数，参数为状态
  def dp(n): 
    # base case： 目标金额为 0 时，所需硬币数量为 0;当目标金额 小于 0 时，无解，返回 -1
    if n == 0: return 0
    if n < 0: return -1

    # 求最小值，所以初始化为正无穷
    res = float('inf')
    for coin in coins:
      subproblem = dp(n - coin) # 做选择：选择就是从面额列表 coins 中选择一个硬币，然后目标金额就会减少
      if subproblem == -1: continue 
      res = min(res, 1 + subproblem)
    return res
  # 状态为 amount
  return dp(amount)
```

写出暴力解法是最关键的一步，接下来使用「备忘录」或者「DP table」消除「重叠子问题」。

```python
def coinChange(coins, amount):
  # 创建备忘录
  memo = dict()

  def dp(n):
    # 直接返回计算过的状态
    if n in memo: return memo[n]
    if n == 0: return 0
    if n < 0: return -1
    res = float('inf')
    for coin in coins:
      subproblem = dp(n - coin)
      if subproblem == -1: continue 
      res = min(res, 1 + subproblem)

    # 记入备忘录
    memo[n] = res if res != float('INF') else -1 
    return memo[n]

  return dp(amount)
```

