---
title: 动态规划
date: 2021-08-31 15:24:23
tags: algorithm
---

动态规划（dynamic planning）问题的一般形式就是**求最值**。比如说让你求最⻓递增子序列、最小编辑距离等等。因为要求最值，肯定要把所有可行的答案穷举出来，然后在其中找最值。但是动态规划的穷举有点特别，因为这类问题存在「重叠子问题」，如果暴力穷举的话效率会极其低下，所以需要「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。因为存在「重叠子问题」，所以一定会具备「最优子结构」，只有列出正确的「状态转移方程」才能正确地穷举。

「状态转移方程」的简单例子： `f(n) = f(n - 1) + f(n - 2)` ，你把 f(n) 想做一个状态 n，这个状态 n 是由状态 n - 1 和状态 n - 2 相加转移而来，这就叫状态转移。

写出「状态转移方程」是最困难的，提供一个框架辅助思考：
明确「状态」 -> 定义 dp 数组/函数的含义 -> 明确「选择」-> 明确 base case。

### 爬楼梯

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？[LeetCode地址](https://leetcode-cn.com/problems/climbing-stairs/)

1. 明确「状态」，也就是原问题和子问题中的变量，很显然该题中的变量是 n。

2. 思考 dp(n) 应该等于什么，也就是思考他的子问题（子问题可以是一组）是什么。分析题意子问题应该是 dp(n - 1) 和 dp(n - 2)，他们和 dp(n) 的关系是：`dp(n) = dp(n - 1) + dp(n - 2)`。

3. 写出「状态转移方程」后考虑最小实现，即`dp(1) = 1`和`dp(2) = 2`

4. 接下来开始填入模板

```python
def climbStairs(n):
  # 最小实现
  if n == 1: return 1
  if n == 2: return 2

  # 创建 dp 数组
  dp = [0] * (n + 1)
  dp[1] = 1
  dp[2] = 2

  for i in range(3, n + 1):
    # 循环中使用状态转移方程
    dp[i] = dp[i - 1] + dp[i - 2]
  return dp[n]
```

<!-- more -->

### 三角形最小路径和

[LeetCode地址](https://leetcode-cn.com/problems/triangle/)

```python
def minimumTotal(triangle):
  n = len(triangle)
  f = [[0] * n for _ in range(n)]
  f[0][0] = triangle[0][0]

  for i in range(1, n):
      # 最左边的值来自最左侧的数据 triangle[i][0]
      f[i][0] = f[i - 1][0] + triangle[i][0]
      # 中间的值来自左侧或者右侧的最小值
      for j in range(1, i):
          f[i][j] = min(f[i - 1][j - 1], f[i - 1][j]) + triangle[i][j]
      # 最右边的值来自最右侧的数据 triangle[i][i]
      f[i][i] = f[i - 1][i - 1] + triangle[i][i]
  
  return min(f[n - 1])
```

### 零钱兑换

有 k 种面值的硬币，面值分别为 c1, c2 ... ck ，每种硬币的数量无限，问最少需要几枚硬币凑出金额 amount，如果不可能凑出，算法返回 -1。
[LeetCode地址](https://leetcode-cn.com/problems/coin-change/)

这个问题具备「最优子结构」。比如你想求 amount = 11 时的最少硬币数(原问题)，如果你知道凑出 amount = 10 的最少硬币 数(子问题)，你只需要把子问题的答案加一(再选一枚面值为 1 的硬币) 就是原问题的答案，因为硬币的数量是没有限制的，子问题之间没有相互制，是互相独立的。

先确定「状态」，也就是原问题和子问题中变化的变量。由于硬币数量无限，所以唯一的状态就是目标金额 amount 。

确定 dp 函数的定义: 当前的目标金额是 n ，至少需要 dp(n) 个硬币凑出该金额。

确定「选择」并择优，也就是对于每个状态，可以做出什么选择改变当前状态。

最后明确 base case，也就终止条件。

```python
def coinChange(coins, amount):
  # dp 函数，参数为状态
  def dp(n): 
    # base case： 目标金额为 0 时，所需硬币数量为 0;当目标金额 小于 0 时，无解，返回 -1
    if n == 0: return 0
    if n < 0: return -1

    # 求最小值，所以初始化为正无穷
    res = float('inf')
    for coin in coins:
      # 做选择：选择就是从面额列表 coins 中选择一个硬币，然后目标金额就会减少
      subproblem = dp(n - coin)
      if subproblem == -1: continue
      # 子问题和原问题的解集的关系为： dp(n) = dp(n-coin) + 1
      res = min(res, 1 + subproblem)
    return res
  # 状态为 amount
  return dp(amount)
```

写出暴力解法是最关键的一步，接下来使用「备忘录」或者「DP table」消除「重叠子问题」。

```python
def coinChange(coins, amount):
  # 创建备忘录
  memo = dict()

  def dp(n):
    # 直接返回计算过的状态
    if n in memo: return memo[n]
    if n == 0: return 0
    if n < 0: return -1
    res = float('inf')
    for coin in coins:
      subproblem = dp(n - coin)
      if subproblem == -1: continue 
      res = min(res, 1 + subproblem)

    # 记入备忘录
    memo[n] = res if res != float('INF') else -1 
    return memo[n]

  return dp(amount)
```
