---
title: 回溯算法
date: 2021-08-30 17:33:20
tags: algorithm
---

### 模板

回溯算法可以用来解决子集、排列、组合问题，基础模板如下：

```python
# nums 选项
def dining(nums):
  desk = []
  # dish: 打菜盘，menus: 菜单
  def backtrack(dish, menus):
    if (满足结束条件):
      desk.append(dish)
    for val in menus:
      # 做选择
      dish.append(val)
      backtrack(dish, 新菜单)
      # 撤销选择
      dish.pop()
  backtrack([], nums)
  return desk
```

为了便于理解上述回溯算法的模板，假设我们去食堂的打菜，在满足指定条件的情况下（视题目而定），把菜放到桌子上。

### 应用

#### 子集

[LeetCode 地址](https://leetcode-cn.com/problems/subsets/)

```python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        desk = []
        def trackBack(dish, menus):
            if (dish not in desk):
                desk.append(dish[:])

            for idx, val in enumerate(menus):
                dish.append(val)
                trackBack(dish, menus[(idx+1):])
                dish.pop()

        trackBack([], nums)
        return desk
```

#### 全排列

[LeetCode 地址](https://leetcode-cn.com/problems/permutations/)

```python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        desk = []
        long = len(nums)
        def backtrack(dish, menus):
            if dish not in desk and len(dish) == long:
                desk.append(dish[:])
            for val in menus:
                dish.append(val)
                temp = menus[:]
                temp.remove(val)
                backtrack(dish, temp)
                dish.pop()
        backtrack([], nums)
        return desk
```

#### 组合

[LeetCode 地址](https://leetcode-cn.com/problems/combinations/)

```python
class Solution:
    def combine(self, n: int, k: int) -> List[List[int]]:
        desk = []
        def backtrack(dish, menus):
            if (len(dish) == 2):
                desk.append(dish[:])
                return

            for val in menus:
                dish.append(val)
                backtrack(dish, range(val + 1, n + 1))
                dish.pop()
        backtrack([], range(1, n + 1))
        return desk
```
