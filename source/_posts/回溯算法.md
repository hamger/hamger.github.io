---
title: 回溯算法
date: 2021-08-30 17:33:20
tags: algorithm
---

### 模板

回溯算法可以用来解决子集、排列、组合问题，基础模板如下：

```python
# nums 选项
def dining(nums):
  desk = []
  # dish: 打菜盘，menus: 菜单
  def backtrack(dish, menus):
    if (满足结束条件):
      desk.append(dish)
    for val in menus:
      # 做选择
      dish.append(val)
      backtrack(dish, 新菜单)
      # 撤销选择
      dish.pop()
  backtrack([], nums)
  return desk
```

为了便于理解上述回溯算法的模板，假设我们去食堂的打菜，在满足指定条件的情况下（视题目而定），把菜放到桌子上。

<!-- more -->

### 应用

#### 子集

[LeetCode 地址](https://leetcode-cn.com/problems/subsets/)

```python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        desk = []
        def trackBack(dish, menus):
            if (dish not in desk):
                desk.append(dish[:])

            for idx, val in enumerate(menus):
                dish.append(val)
                trackBack(dish, menus[(idx+1):])
                dish.pop()

        trackBack([], nums)
        return desk
```

#### 全排列

[LeetCode 地址](https://leetcode-cn.com/problems/permutations/)

```python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        desk = []
        long = len(nums)
        def backtrack(dish, menus):
            if dish not in desk and len(dish) == long:
                desk.append(dish[:])
            for val in menus:
                dish.append(val)
                newMenus = menus[:]
                newMenus.remove(val)
                backtrack(dish, newMenus)
                dish.pop()
        backtrack([], nums)
        return desk
```

#### 组合

[LeetCode 地址](https://leetcode-cn.com/problems/combinations/)

```python
class Solution:
    def combine(self, n: int, k: int) -> List[List[int]]:
        desk = []
        def backtrack(dish, menus):
            if (len(dish) == 2):
                desk.append(dish[:])
                return

            for val in menus:
                dish.append(val)
                backtrack(dish, range(val + 1, n + 1))
                dish.pop()
        backtrack([], range(1, n + 1))
        return desk
```

### 变形
根据不同的题型，回溯算法中变化的部分是**结束条件**和**新菜单**。

新菜单指的是，每次可选项的集合，根据不同的题目，新菜单是不一样的。
#### 不包含重复元素的情况
如果解集忽略子项的排序差异（例如求子集），则新菜单为：
```python
newMenus = menus[(idx+1):]
```

如果解集不忽略子项的排序差异（例如求全排列） ，新菜单为：
```python
newMenus = menus[:]
newMenus.remove(val)
```
#### 包含重复元素的情况
例子：[零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/)
```python
def change(amount, coins):
  desk = []
  coins.sort()
  def backtrack(dish, menus):
    if sum(dish) > amount:
      return
    elif sum(dish) == amount:
      dish.sort() # 忽略子项的排序差异时，先排序在判断是否在结果中
      if dish not in desk:
        desk.append(dish[:])
      return 
    for idx, val in enumerate(menus):
      dish.append(val)
      # 新菜单：小于剩余值面额的零钱
      residue = amount - sum(dish)
      backtrack(dish, [i for i in menus if i <= residue])
      dish.pop()
  backtrack([], coins)
  print(desk) # 打印所有符合的组合
  return len(desk)

print(change(5, [1,2,5]))
```